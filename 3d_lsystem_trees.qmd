---
title: "3D L-Systems: Trees"
format: 
  html: 
    code-fold: true
    cache: true
---

```{r setup}
#| echo: false
library(rgl)
#knitr::knit_hooks$set(webgl = hook_webgl)
options(rgl.useNULL = TRUE) # Suppress the separate window.
source("vector_operations.R")
```

## 3D L-System

In this project I'll explore how to do a three dimensional implementation of the Lindenmayer system. The core of this is from the [Algorithmic Beauty of Plants](http://algorithmicbotany.org/papers/abop/abop.pdf) (abbreviated ABOP), though I found myself wishing that I had access to the paper mentioned by [Honda](https://www.sciencedirect.com/science/article/abs/pii/0022519371901913?via%3Dihub) as there were some points that were unclear, particularly the incorporation of tropism.\
This implementation requires two new items compared to prior systems: the ability to work in three dimensions and the ability to accept parameters.

### How to work in 3D

In the former implementation of L-systems, points were generated by changing the position of a "turtle" and storing the x-position, y-position, and angle $(x,y,\alpha)$. For 3D, not only is the turtle's position $(x,y,z)$ needed but also it's current orientation in space. In ABOP, this is done with three unit vectors $\vec{H}, \vec{L}, \vec{U}$ indicating the turtle's heading, left, and up directions. These vectors are mutually orthogonal: $\vec{H} \times \vec{L} = \vec{U}$. Rotations of the turtle can then be expressed as:

$$
[\vec{H}' \vec{L}' \vec{U}'] = [\vec{H} \vec{L} \vec{U}] \mathbf{R}
$$

Where $\mathbf{R}$ is a 3x3 rotation matrix. I used 4 rotation matrices in this writeup: the three from APOB to rotate around $\vec{H}, \vec{L}$, and $\vec{U}$

```{=tex}
\begin{aligned}
\mathbf{R_U}(\alpha) &= \begin{bmatrix}
\cos{\alpha} & \sin{\alpha} & 0 \\
-\sin{\alpha} & \cos{\alpha} & 0 \\
0 & 0 & 1
\end{bmatrix} \\

\mathbf{R_L}(\alpha) &= \begin{bmatrix}
\cos{\alpha} & 0 & -\sin{\alpha} \\
0 & 1 & 0 \\
\sin{\alpha} & 0 & \cos{\alpha}
\end{bmatrix} \\

\mathbf{R_H}(\alpha) &= \begin{bmatrix}
1 & 0 & 0 \\
0 & \cos{\alpha} & -\sin{\alpha} \\
0 & \sin{\alpha} & \cos{\alpha}
\end{bmatrix}
\end{aligned}
```
and one to rotate around an arbitrary axis $\mathbf{n}$ by $\theta$ from [3D Game Engine Programming](https://www.3dgep.com/3d-math-primer-for-game-programmers-matrices/#Rotation_about_an_arbitrary_axis)

```{=tex}
\begin{bmatrix}
n_x^2(1-\cos{\theta})+\cos{\theta} & n_xn_y(1-\cos{\theta})-n_z\sin{\theta} & n_xn_z(1-\cos{\theta})+n_y\sin{\theta} \\
n_xn_y(1-\cos{\theta})+n_z\sin{\theta} & n_y^2(1-\cos{\theta})+\cos{\theta} & n_yn_z(1-\cos{\theta})-n_x\sin{\theta} \\
n_xn_z(1-\cos{\theta})-n_y\sin{\theta} & n_yn_z(1-\cos{\theta})+n_x\sin{\theta} & n_z^2(1-\cos{\theta})+\cos{\theta}
\end{bmatrix}
```

### Exploring 3d vectors

Here I'll illustrate how the 3D orientation vectors are transformed by rotation around different directions.

Note:

-   H is in red = $[0,0,1]$\
-   L is in green = $[1,0,0]$\
-   U is in blue = $[0,1,0]$\
-   $[HLU]$ is bold, $[H'L'U']$ is thin

#### Rotate 30 degrees around Heading

```{r explore3d_RH}
#| echo: FALSE
H0 <- c(0,0,1); L0 <- c(1,0,0); U0 <- c(0,1,0)
T0 <- matrix(c(H0, L0, U0), nrow = 3)
draw_T0(T0, lwd = 4); draw_T0(T0 %*% RH(30), add = TRUE, lwd = 1)
view3d(theta=45, phi = 30)
rglwidget()
```

#### Rotate 30 degrees around Left

```{r explore3d_RL}
#| echo: FALSE
H0 <- c(0,0,1); L0 <- c(1,0,0); U0 <- c(0,1,0)
T0 <- matrix(c(H0, L0, U0), nrow = 3)
draw_T0(T0, lwd = 4); draw_T0(T0 %*% RL(30), add = TRUE, lwd = 1)
rglwidget()
```

#### Rotate 30 degrees around Up

```{r explore3d_RU}
#| echo: FALSE
H0 <- c(0,0,1); L0 <- c(1,0,0); U0 <- c(0,1,0)
T0 <- matrix(c(H0, L0, U0), nrow = 3)
draw_T0(T0, lwd = 4); draw_T0(T0 %*% RU(30), add = TRUE, lwd = 1)
rglwidget()
```

#### Rotate 30 degrees around \[1,1,1\]

```{r explore3d_RT}
#| echo: FALSE
H0 <- c(0,0,1); L0 <- c(1,0,0); U0 <- c(0,1,0)
T0 <- matrix(c(H0, L0, U0), nrow = 3)
draw_T0(T0, lwd = 4); draw_T0(Ra(T0, c(1,1,1), 30), add = TRUE, lwd = 1, tropism = c(1,1,1))
rglwidget()
```

### Including Parameters

To overcome limitations of the original L-system implementation such as an inability to model changes over time, Lindenmayer proposed that a symbol should also have a parameter associated with it. This is accomplished by changing the alphabet a L-system uses to a series of "modules" consisting of letters with associated parameters. Additionally, a production rule can require a parameter pass a test to apply the rule. Borrowing from ABOP the example production:

$A(t): t>5 \rightarrow B(t+1)CD(t\wedge0.5, t-2)$

will match a module in the parametric word if:

-   the letter in the module and the letter in the production predecessor are the same,\
-   the number of actual parameters in the module is equal to the number of formal parameters in the production predecessor, and
-   the condition evaluates to true if the actual parameter values are substitute for the formal parameters in the production.

If the above rule is applied to $A(9)$, the letter matches, the number of parameters matches, and 9 passes the condition so the production rule will result in $B(10)CD(3,7)$.

### Turtle interpretation of parametric words

A basic set of parameters used in this implementation are:

-   $F(a)$: move forward step length $a$. Turtle position changes to $(x+a\vec{H}_x,y+a\vec{H}_y,z+a\vec{H}_z)$ and a line is drawn from start to finish\
-   $!(a)$: set trunk thickness to $a$\
-   $\&(a)$: rotate around $\vec{L}$ by angle $a$ degrees\
-   $/(a)$: rotate around $\vec{H}$ by angle $a$ degrees
-   $[]$: Push/pop turtle's current state to stack.

### Tropism

The bending of a tree's branches due to either an environmental effect such as wind or gravity is simulated by rotating the turtle's direction a small amount in the direction of a $tropism$ vector $\vec{T}$ after drawing each segment. I found the explanation in ABOP to be either incomplete or misleading as I was unable to get the exact structures presented in the book but I got close on most cases.\
The orientation of the turtle is adjusted by $\alpha$ according the formula $\alpha = e|\vec{H} \times \vec{T}|$ where $e$ captures the tree's susceptibility to bending. As ABOP does not show an example or equation of the application of this bending to the turtle's orientation I chose to model it as $[H'L'U'] = R[HLU]$ where $R$ is the rotation matrix about an arbitrary axis. The axis for the rotation matrix was chosen to be $\vec{H} \times \vec{T}$ and the rotation angle $\alpha$.

## Implementation in R

The following functions are setup to produce a tree from Figure 2.8 of ABOP that is produced by the following `axiom` $\omega$ and production rules $p_1, p_2, p_3$:

$$
\begin{aligned}
&\omega: !(1)F(200)/(45)A \\
&p_1: A: * \rightarrow !(v_r)F(50)[\&(a)F(50)A]/(d_1) \\
&  \hspace{40mm}[\&(a)F(50)A]/(d2)[\&(a)F(50)A]\\
&p_2: F(l): * \rightarrow F(l * l_r) \\
&p_3: !(w): * \rightarrow !(w*v_r)
\end{aligned}
$$



To implement a 3D parametric system in R, the task was broken down into creating several functions:

1.  Vector manipulation functions\
2.  Rotation matrix functions
3.  Apply single production rules to input function
4.  Generate L-system by iterating over input $n$ times function
5.  Take L-system sentence and convert to points for plotting function

### Vector operations

To perform vector operations in R, I chose to create two functions that handle the cross product `cross(x,y)`and the magnitude of a vector `norm_vec(x)`.

```{r vector operations}
#| code-summary: "Code: Vector operations"
#| eval: FALSE
# cross product
cross <- function(x, y, i=1:3) {
  # A version of this on statology.com includes ability 
  # to create a 3D vec from 2D that isn't needed here. 
  j <- function(i) (i-1) %% 3+1
  return (x[j(i+1)]*y[j(i+2)] - x[j(i+2)]*y[j(i+1)])
}

# Vector norm
norm_vec <- function(x) sqrt(sum(x^2))
```

### Rotation Matrices

Along with creating functions for the cross product and norm of vectors, having functions that find the rotation matrices around $\vec{H}, \vec{L}, \vec{U}$ and an arbitrary axis is another time saving convenience. I created the functions `RH`, `RL`, and `RU` to rotate around the turtle orientation vectors and `RT` to rotate toward the tropism vector.

```{r rotation matrices}
#| code-summary: "Code: Rotation matrices"
#| eval: FALSE
# "Up" vector rotation matrix, returns matrix
RU <- function(a) {
  a <- a*pi/180 # convert degrees to radians
  matrix(c(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1), nrow = 3)
}

# "Left" vector rotation matrix, returns matrix
RL <- function(a) {
  a <- a*pi/180 # convert degrees to radians
  matrix(c(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a)), nrow = 3)
}

# "Heading" vector rotation matrix, returns matrix
RH <- function(a) {
  a <- a*pi/180 # convert degrees to radians
  matrix(c(1, 0, 0, 0, cos(a), sin(a), 0, -sin(a), cos(a)), nrow = 3)
}

# Rotate T0 toward tropism vector, returns rotated T0
RT <- function(T0, tropism = c(0,0,-1), e){
  # alpha = rotation amount, e*|HxT|
  a <- e*norm_vec(cross(T0[,1], tropism)) 
  # Chose rotation axis to be |HxT|
  r <- cross(T0[,1], tropism) #rotation axis
  r <- if(a != 0) { # normalize
    r/norm_vec(r)
  } else {
    r
  }
  
  # rotation matrix - arbitrary axis
  rot_mat <- matrix(c(r[1]^2*(1-cos(a))+cos(a), 
                      r[1]*r[2]*(1-cos(a))+r[3]*sin(a), 
                      r[1]*r[3]*(1-cos(a))-r[2]*sin(a), 
                      r[1]*r[2]*(1-cos(a))-r[3]*sin(a),
                      r[2]^2*(1-cos(a))+cos(a), 
                      r[2]*r[3]*(1-cos(a))+r[1]*sin(a), 
                      r[1]*r[3]*(1-cos(a))+r[2]*sin(a), 
                      r[2]*r[3]*(1-cos(a))-r[1]*sin(a), 
                      r[3]^2*(1-cos(a))+cos(a)),
                    nrow = 3)
  # does order of product matter? it sure does. This is how it's defined in the source: 
  # https://www.3dgep.com/3d-math-primer-for-game-programmers-matrices/#Rotation_about_an_arbitrary_axis
  
  rot_mat %*% T0
}
```

### Axiom and production rules  
To convert the above axiom and production rules into something R can interpret, I chose to store them as a list. The advantage the list has over a string is that it simplifies the use of parameters as a list can store for each letter one or more parameters that can be easily extracted, manipulated, and stored.  
So that different parameters can be passed to the production rules, I chose to make it a function that accepts the parameters that can be changed. What each of these symbols and parameters signifies will be expanded in the "Convert L-Systems to Points" section below.  

```{r axiom and rules}
#| code-summary: Axiom and Rules
# Tree axiom for figure 2.8 from ABOP
axiom <- list(
  list(symbol = "!", param = 1), 
  list(symbol = "F", param = 200), 
  list(symbol = "/", param = 45), 
  list(symbol = "A")
)

# Rules, initial state 2.8a parameters
rules <- function(d1 = 94.74, d2 = 132.63, a = 18.95, lr = 1.109, vr = 1.732) {list(
  A = list(
    list(symbol = "!", param = vr), 
    list(symbol = "F", param = 50), 
    list(symbol = "["), 
    list(symbol = "&", param = a), 
    list(symbol = "F", param = 50), 
    list(symbol = "A"), 
    list(symbol = "]"), 
    list(symbol = "/", param = d1), 
    list(symbol = "["),
    list(symbol = "&", param = a), 
    list(symbol = "F", param = 50), 
    list(symbol = "A"), 
    list(symbol = "]"), 
    list(symbol = "/", param = d2), 
    list(symbol = "["), 
    list(symbol = "&", param = a), 
    list(symbol = "F", param = 50), 
    list(symbol = "A"), 
    list(symbol = "]")
  ), 
  F = list(
    list(symbol = "F", param = lr)
  ), 
  "!" = list(
    list(symbol = "!", param = vr)
  )
)}

```

### Apply production rule

In the prior implementation of L-systems, the rules were applied over a string. As this implementation requires a parameter to be associated with each letter, storing the system as a list was a natural route.\
The `apply_rules` function looks at a `symbol` that is a list with names `symbol` and `param` and compares it to a second list of `rules` that stores the production rules for each letter of the system. If the input `symbol` matches a name of a rule in `rules`, the corresponding rule is returned by the function. If no match is found, the input symbol is returned. Also in this function, if `F` or `!` was the input symbol, these require multiplying their input parameter by the rule parameter.

```{r production rule}
#| code-summary: "Code: Apply production rule"
apply_rules <- function(symbol, rules) {
  if (symbol$symbol %in% names(rules)) {
    transformed_symbol <- rules[[symbol$symbol]]
    # Apply parameter transformation if symbol is F or !
    if(symbol$symbol %in% c("F", "!")) {
      # for (i in seq_along(transformed_symbol)) {
        # Change parameter value of old symbol by product with new parameter
        transformed_symbol[[1]]$param <- transformed_symbol[[1]]$param * symbol$param
      #}
    }
    return(transformed_symbol)
  } else {
    return(list(symbol))
  }
}
```

### Generate L-System

This function is finally the main generator of the 3D L-system. It takes in a list `axiom` - the starting point of the tree, a list of production `rules` to transform the axiom in each generation, and the number of `iterations` to run through. The function operates by running through each `symbol` in the current sequence and passing it to `apply_rules` building a new sequence. This is looped over `iterations` times on each newly generated sequence before the final sequence is returned.

```{r Generate l-system}
#| code-summary: "Code: Generate L-System"
# Define function to generate L-system using apply_rules
generate_l_system <- function(axiom, rules, iterations) {
  sequence <- axiom
  for (i in 1:iterations) {
    new_sequence <- vector(mode = "list", length = 0)
    for (symbol in sequence) {
      transformed_symbol <- apply_rules(symbol, rules)
      new_sequence <- c(new_sequence, transformed_symbol)
    }
    sequence <- new_sequence
  }
  return(sequence)
}
```

### Convert L-System sentence to points

Finally, the output of `generate_l_system(axiom, rules, iterations)` must be converted to set of positions by interpreting each letter and parameter as a set of instructions to the turtle. This is accomplished in the same was as prior L-systems with the added wrinkle that now the sequence of instructions is saved as a list of symbols and parameters.\
The `draw_3d_lsystem` function takes the same arguments as `generate_l_system` in addition to a `tropism` vector and susceptibility to bending factor `e`. The function then:

1.  Generates the l-system by calling `generate_l_system`
2.  Sets the turtle's initial state\
3.  Initializes the branch `[]` push/pop list
4.  Iterates over each individual action in the l-system
    -   If `F`: move forward along heading vector by `param` value, then adjust heading toward tropism vector. Also, set `lwd` parameter
    -   If `!`: update turtle's `lwd` (branch thickness)
    -   If `/`, rotate orientation by `RH(param)`
    -   If `&`: rotate orientation by `RL(param)`
    -   If `[`: push current state to stack
    -   If `]`: pop last state from stack and set to current
    -   If `A`: do nothing, left over generation function
    
These actions also take several parameters that are taken from the `rules` and are:  
1. $d_1$: divergence angle 1
2. $d_2$: divergence angle 2
3. $a$: branching angle
4. $l_r$: elongation rate
5. $v_r$: width increase rate

```{r l-system to points}
#| code-summary: L-system to Points
points_3d_lsystem <- function(axiom, rules, iterations, tropism = c(0,0,-1), e = .14) {
  # Create the l_system instructions
  tree <- generate_l_system(axiom, rules, iterations)
  
  # Establish turtle initial state: heading along z, left on x, up on y
  H0 <- c(0,0,1); L0 <- c(1,0,0); U0 <- c(0,1,0)
  T0 <- matrix(c(H0, L0, U0), nrow = 3)
  x0 <- 0; y0 <- 0; z0 <- 0
  lwd <- 0
  # turtle position, including seg to aid in plotting points later
  turtle <- data.frame(x = x0, y = y0, z = z0, lwd = lwd, seg = 0)
  
  branch_pop <- list()
  pop_lvl <- 0
  
  for (action in tree) {
    if(action$symbol == "F") {
      # move forward distance of param
      lwd <- turtle[nrow(turtle), "lwd"]
      x <- turtle[nrow(turtle), "x"] + action$param * T0[1,1]
      y <- turtle[nrow(turtle), "y"] + action$param * T0[2,1]
      z <- turtle[nrow(turtle), "z"] + action$param * T0[3,1]
      
      seg <- turtle[nrow(turtle),"seg"]
      turtle <- rbind(turtle, data.frame(x=x, y=y, z=z, lwd=lwd, seg = seg+1))
      # TROPISM - results not entirely consistent with book, mainly on plot d
      T0 <- RT(T0, tropism, e)
      
    } else if (action$symbol == "!") {
      # set lwd to param
      lwd <- action$param
      turtle[nrow(turtle), "lwd"] <- lwd
    } else if (action$symbol == "/") {
      # Roll right by angle param, using rotation matrix $R_H(param)$
      T0 <- T0 %*% RH(action$param)

    } else if (action$symbol == "&") {
      # Pitch down by angle param, using rotation matrix $R_L(param)$
      T0 <- T0 %*% RL(action$param)
      
    } else if (action$symbol == "[") {
      # add current state to branch_pop
      pop_lvl <- pop_lvl + 1
      branch_pop <- c(branch_pop, list(list(pos = turtle[nrow(turtle),], 
                                            T = T0)))
      
    } else if (action$symbol == "A") {
      # Do nothing, consider removing A from list before creating turtle
      
    } else {
      # set top stack value to current state
      turtle <- rbind(turtle, 
                      #c(NA, NA, NA, NA), 
                      branch_pop[[pop_lvl]]$pos)
      T0 <- branch_pop[[pop_lvl]]$T
      
      # Remove last of stack. 
      branch_pop <- branch_pop[-length(branch_pop)]
      pop_lvl <- pop_lvl - 1
    }
  }
  turtle
}
```

### Draw L-System  
The final function required is one that takes a generated set of points and creates a plot of the structure. For this, I chose to use `rgl::plot3d` and associated functions. The primary limitation I found is that currently `plot3d` does not accept a vector of colors or line widths so I was unable to change the appearance of each branch segment without the use of a `for` loop. The function below:  

1. Sets the color palette of the branches  
2. Selects an appropriate number of colors depending on the max length of a branch and adds green for the last color to evoke leaves  
3. Opens a new rgl device  
4. Sets the window size and viewing angle so different trees are consistent  
5. Iterates over each branch of the tree drawing a line segment with `lines3d`, the `lwd` of the section's end point, and a color.  

```{r}
#| code-summary: Create Graph
draw_3d_lsystem <- function(tree) {
  # colors for branches, gradient of brown
  yb<-colorRampPalette(c("#1B0000","#4d2B0b","chocolate4"))
  # Color each segment, make last green 
  cols <- c(yb(max(tree$seg)-1),"green4")
  
  # Plot!
  open3d(silent = TRUE)
  par3d(windowRect = c(0,100,500,600)) # consistent window size
  view3d(theta = 0, phi = -75, zoom = .6) # consistent window view
  plot3d(tree, type = "n") # blank window for xyz extents
  for (i in 1:(nrow(tree)-1)) { # add each branch
    if(tree[i,"seg"] < tree[i+1,"seg"]) {
      lines3d(tree[i:(i+1),], lwd = tree[i+1,]$lwd/1.73, 
              col = cols[tree[i,"seg"]+1])
    }
  }
}
```

## Results  
Trying to include the tree as an interactive plot similar to the vector visualizations above caused the website to slow to the point of unusability. As an alternative, using `rgl::movie3d` a gif was created to highlight the resulting tree structure.  

### Figure 2.8a  
The default parameters I created for the `rules()` function recreate Figure 2.8a from ABOP and are: 

$$
d_1: 94.74^{\circ} \\
d_2: 132.63^{\circ} \\
a: 18.95^{\circ} \\
l_r: 1.109 \\
\vec{T} = (0,0,-1) \\
e = .22 \\
n = 6 \\
$$
```{r Treea}
#| eval: false
treea <- points_3d_lsystem(axiom, rules(), 6)
draw_3d_lsystem(treea)

```

![Treea](tree_figa_loop.gif)

### Figure 2.8b  
To recreate 2.8b, the following parameters are passed to `rules` and `points_3d_lsystem`:

$$
d_1: 137.5^{\circ},
d_2: 137.5^{\circ},
a: 18.95^{\circ},
l_r: 1.109,
\vec{T} = (0,0,-1),
e = .14,
n = 8
$$

```{r Treeb}
#| eval: false
rulesb <- rules(137.5, 137.5,18.95,1.109,1.732)
treeb <- points_3d_lsystem(axiom, rulesb, iterations = 8, e = .14)
draw_3d_lsystem(treeb)
```

![Treeb](tree_figb_loop.gif)

### Figure 2.8c  
To recreate 2.8c, the following parameters are passed to `rules` and `points_3d_lsystem`:

$$
d_1: 112.5^{\circ},
d_2: 157.5^{\circ},
a: 22.5^{\circ},
l_r: 1.790,
\vec{T} = (-.02,0,-1),
e = .27,
n = 8
$$

```{r Treec}
#| eval: false
rulesc <- rules(112.5, 157.5,22.5,1.790,1.732)
treec <- points_3d_lsystem(axiom, rulesc, iterations = 8, tropism = c(-0.02, 0, -1), e = .14)
draw_3d_lsystem(treec)
```

![Treec](tree_figc_loop.gif)

### Additions  
The building block of a tree created here can be expanded to include many other features. For example, by including the `seg` segment number parameter color was added to the structure by tracking which generation a particular segment was added in.  
Another feature that can be added with a small function is generating a leaf at the end of each branch. The `make_leaf` function below takes in the last two segments of a branch and:  

1. Extracts the segment end points as vectors $p_1,p_2$  
2. Finds the orientation vector $v_1 = p_2 - p_1$  
3. Rotates the orientation around the "Up" vector by a default of $15^{\circ}$ in both positive and negative directions, adding the result to $p_1$ to get two new points $p_l, p_r$
4. Forms a triangle with `polygon3d` from points $p_1, p_l, p_r$  

```{r add leaves}
#| code-summary: Add_leaf function
make_leaf <- function(pts, deg = 15) {
  # pts should be passed in as tree[(i-1):i]
  p1 <- as.vector(pts[1,], mode = "numeric")
  p2 <- as.vector(pts[2,], mode = "numeric")
  v1 <- p2 - p1
  pl <- p1 + v1 %*% RU(deg)
  pr <- p1 + v1 %*% RU(-deg)
  polygon3d(rbind(p1,pl,pr),col = "green4")
}
```

This new function can then be added to the `draw_3d_lsystem` function as an extra condition in the `for` loop: if at the end of a branch, draw a leaf.  

![Treeb with leaves](tree_figb_leaf_loop.gif)

## Conclusion  
Implementing a 3D L-system in R used several functions to handle vectors, store rules, apply rules, create the L-system, and plot the result. From Algorithmic Beauty of Plants, figures 2.8a - 2.8c were recreated with color and the addition of a leaf feature were explored.  
Further work on more detailed leaves, defining a branch polygon feature, adding variability in the structure via a stochastic 3d l-system, and more can be envisoned and may be explored at a future time. Ultimately, coding this in R was a great amount of fun combined with learning about 3d systems and storing information in lists.  